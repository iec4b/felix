#file_info.py
import xml.etree.ElementTree as ET
import sys
import os
import re

#create a blank list to populate with lists of metadata for each individual file
lol = []
#loop through each xml file listed in 'output', which is generated by iterate.py
for child in output:
	filename = child
	filepath = directory+"/"+child
	document = ET.parse(filepath)
	#map the xml with ElementTree
	root = document.getroot()
	#navigate to the AMD audio metadata within the xml hierarchy
	metadata = root.findall('{http://www.loc.gov/METS/}amdSec/{http://www.loc.gov/METS/}techMD/{http://www.loc.gov/METS/}mdWrap/{http://www.loc.gov/METS/}xmlData/{http://www.loc.gov/AMD/}AUDIOMD')
	#loop through the audio metadata
	for child in metadata:
		#create a new row for each file described in the metadata
		row = []
		#the first item in each list will be the filename of the xml file itself, so that all of the data to follow can be tracked back to its source
		row.append(filename)
		#create a variable to hold the attributes of the AMD audio elements
		item = child.attrib
		#isolate just the attributes for the mp3 files (where item['ID'] includes 'streaming.mp3')
		mp3s = re.findall('.+streaming.mp3', item['ID'])
		#loop through the mp3 metadata, where each child corresponds to one of one or two sides of the cassette
		for side in mp3s:
			#save the name of the side to the list of lists (this will be a filename like Box_X_X_a.mp3)
			row.append(side)
			for gchild in child:
				for ggchild in gchild:
					#this conditional finds the xml elements containing filesizes
					if ggchild.tag == '{http://www.loc.gov/AMD/}format_note':
						#run a regex search for just the numbers, nothing else (no KB marking -- that's already included in the MARC template so we don't need it)
						substring = re.findall('\d+',ggchild.text)
						#this if else accounts for the rare case where the filesize is an integer value
						if len(substring) == 1:
							row.append(substring[0])
						#most of the filesizes are decimal values, so this concatenates the results of the regex search, which returns lists of every substring of digits before and after the decimal. This concatenation just puts them back together with a decimal point inbetween.
						else:
							row.append(substring[0]+'.'+substring[1])
					#this conditional finds the xml element containing the duration of the audio playback and adds that value to the list within the list of lists. Remember, each list will become a row in the csv file when this program is called by the csv_writer script.		
					if ggchild.tag == '{http://www.loc.gov/AMD/}duration':
						row.append(ggchild.text)
			#After the final nested loop has finished, it adds the completed row to the list of lists. Then the program returns to the beginning of the sequence with a new filepath (child of the iterate.py output listing all of the xml files to parse).		
			lol.append(row)

